保边滤波器(Edge Preserving Filter)是指在滤波过程中能够有效的保留图像中的边缘信息的一类特殊滤波器。其中双边滤波器（Bilateral filter）、引导滤波器（Guided image filter）、加权最小二乘法滤波器（Weighted least square filter）为几种比较广为人知的保边滤波器。下面对每种滤波器进行一一介绍。


###双边滤波器
Bilateral的意思是：Affecting or undertaken by two sides equally，表示由双方（边）平等共同决定，有点类似于地位平等的双边谈判的感觉。双边滤波器中地位平等的双边即是指滤波的最终结果由像素值（值域）和像素位置（空域）来共同决定。最为常见的高斯平滑滤波器就是由像素位置单边决定的滤波器，其表达式如下：
$$
g1(i,j) = \frac{\sum_{k, l}{f(k,l)*d(i,j,k,l)}}{\sum_{k, l}{d(i,j,k,l)}}
$$


其中的$w(i, j, k, l)$为权重系数

$$
d(i, j, k, l) = exp(-\frac{(i-k)^2+(j-l)^2}{2\sigma_{d}^2})
$$

双边滤波器中的一边即为上述常见的高斯平滑滤波器，两个像素物理距离越大则权值越小，反之则权值越大。双边滤波器中另一边则由像素值值域决定，两个像素，值相差越小，那么越不可能是边缘，那么越应该对其进行平滑处理，也就是应该提高其在滤波器中的权值（类似于空域中距离越近）而反之，像素值相差越大则越有可能是边缘，则应该尽力保留（类似于空域中距离越远），类比上面的公式，可以得到值域的高斯滤波器如下：
$$
g2(i,j) = \frac{\sum_{k, l}{f(k,l)*r(i,j,k,l)}}{\sum_{k, l}{r(i,j,k,l)}}
$$
$$
r(i, j, k, l) = exp(-\frac{||f(i,j)-f(k,l)||^2}{2\sigma_{r}^2})
$$

双边滤波器由上述两个滤波器共同决定，因此其最终形式为:
$$
bilateral\_filter(i,j) = \frac{\sum_{k, l}{f(k,l)*w(i,j,k,l)}}{\sum_{k, l}{w(i,j,k,l)}}
$$
每个位置的权重由上述两个滤波器的相应权重共同决定：
$$
w(i, j, k, l) =exp(-\frac{(i-k)^2+(j-l)^2}{2\sigma_{d}^2}-\frac{||f(i,j)-f(k,l)||^2}{2\sigma_{r}^2})
$$
 使用最为原始的Matlab代码实现上述滤波器：

```matlab
function [ tonedMap ] = navieBilateral( radMap,dw,rw,dsigma,rsigma)
%	NAVIEBILATERAL Summary of this function goes here
%   Detailed explanation goes here
%   radmap为照度图像，dw和dr分别为空域和值域的滤波器大小
%   dsigma和rsigma分别为空域和值域的高斯sigma因子
%   首先生成空域的高斯滤波器权重因子
[x,y] = meshgrid(-dw:dw,-dw:dw);
g1 = exp(-(x.^2+y.^2)/(2*dsigma^2));  

%   对图像进行对称扩张，保证在图像的边缘仍然可以进行处理   
pw = max(dw,rw);
padradMap = padarray(radMap,[pw pw],'symmetric');
dim = size(padradMap);
tonedMap = zeros(dim(1)-pw,dim(2)-pw);

for i= pw+1:dim(1)-pw
    for j=pw+1:dim(2)-pw
        I = padradMap(i-rw:i+rw,j-rw:j+rw);             %取相应图像块
        g2 = exp(-(I-padradMap(i,j)).^2/(2*rsigma^2));  %值域滤波因子生成
        w = g1(:).*g2(:);                               %生成双边因子
        tonedMap(i-pw,j-pw) = sum(w.*I(:))/sum(w);      
    end
end

end
```

双边滤波器利用了一个值域的高斯函数来调整滤波器在遇到图像边缘时的表现，使其在图像的一般区域表现出平滑性，同时在边缘区域尽量消除其平滑性，我们通过一个简单的实验来理解这一过程。


###双边滤波器进行HDR图像压缩
 双边滤波器可以用于HDR图像压缩，其压缩原理很简单，HDR图像经过双边滤波器滤波以后得到一个Base layer，原始图像与Base layer之差则为Detail layer，对base layer进行压缩以后再将detail layer叠加上去就可以得到压缩后的图像。

```matlab
% Implementation of "Fast Bilateral Filtering for the Display of High-Dynamic-Range Images"
% Input "radmap" must be of type double!
function tonedImage = toneMapDurand(radmap,dw,rw,dsigma,rsigma,contrast)
    %首先分离图像的baselayer和detaillayer
	radmap = log10(radmap)；
    base = navieBilateral(radmap,dw,rw,dsigma,rsigma);
    detail = radmap - base;
    logmax = max(base(:));
    logmin = min(base(:));
    compressionFactor = log10(contrast)/(logmax-logmin);
    log_absolute_scale =  logmax*compressionFactor;
    log_compressed = base * compressionFactor + detail  - log_absolute_scale;
    tonedImage = 10.^(log_compressed);     
end
```
 上述过程中，通过双边滤波器所得到的base layer其实就是HDR图像中存在的一些明显的大起伏，举个例子，HDR图像就像我国地势一样，动态分布很大，错综复杂，任何一个地区都是高低起伏不定的，但是通过双边滤波器以后，可以把我国的地势大体看成西部高原，中部丘陵，东部平原，这三个台阶就是所谓的base layer。在base layer的基础上，一些局部的高低变化，比如平原地区的小山峰，丘陵地区的盆地，这些就是detail layer。对HDR图像的压缩，就是压缩西部高原，中部丘陵，东部平原三者之间的高度差。



###引导滤波器

 引导滤波器是利用优化方法解决保边滤波的问题。所谓保边，也就是保持梯度的相对性，引导滤波器的一个重要假设就是认为，保边滤波后的结果和引导图像在滤波窗口内呈现线性关系：
$$
q_{i} = a_{k}I_{i}+b_{k} , \forall i \in \omega_{k}
$$
其中，$I$是引导图像，$q$是输出，$\omega$是以$k$为中心像素的窗口，$a$和$b$都为该窗口对应的线性系数。上面的线性关系自然保证了图像梯度的相对性不变,因为对图像两边求导可以得到:
$$
\triangledown q = a\triangledown I
$$
但是，如果图像中任何一个地方的系数$a$和$b$都相同，那么无异于对整个图像进行了一个线性变换，并没有起到保边滤波的功效。要达到保边滤波的效果，**我们期望$a$和$b$是随着图像内容变化的，在边缘区域，$a$尽量大，保持梯度，在平滑区域$a$尽量小，以尽量平滑**。作者认为输出$q$应该尽量和原始图像一致，并以此为约束条件来试图解出$a$和$b$。输出$q$和原始图像尽量一致，也就是最小化如下cost function：
$$
E(a_{k},b_{k}) = \sum_{i \in \omega_{k}}((a_{k}I_{i}+b_{k}-p_{i})^2+\epsilon a_{k}^2)
$$

这里，$\epsilon$是对较大$a_{k}$进行惩罚的正则系数。为了得到上式的最小值，对两个参数$b$和$a$分别求导：
$$
\frac{\triangledown E}{\triangledown b} = \sum_{i\in \omega_{k}} 2(a_{k}I_{i}+b_{k}-p_{i}) 
$$
令上式等于零，可以解得:
$$
b_{k} =\frac{ \sum_{i \in \omega_{k}}({p_{i}-a_{k}I_{i}})}{|\omega|}
$$
   其中，$|\omega|$为窗口$w$中像素数目，那么，进一步的，用$\overline{p}_{k}$、$\mu_{k}$分别表示输入图像和引导图像在窗口$|\omega|$中的均值：
$$
b_{k} = \overline{p}_{k}-a_{k}\mu_{k} 
$$
再对$a$求导：
$$
\frac{\triangledown E}{\triangledown a} =   \sum_{i\in \omega_{k}}(2(a_{k}I_{i}+b_{k}-p_{i})I_{i}+2\epsilon a_{k} )
$$
令上式等于0，并将$b_{k}$的值带入可以得到：
$$
\sum_{i\in \omega_{k}}a_{k}（I_{i}^2-\mu_{k}I_{i}+\epsilon) -(p_{i}I_{i}-  \overline{p}_{k}I_{i})=0
$$

解出$a_{k}$的值如下：
$$
  a_{k} = \frac{\sum_{i\in \omega_{k}}( p_{i}I_{i}-  \overline{p}_{k}I_{i})}{ \sum_{i\in \omega_{k}}(I_{i}^2-\mu_{k}I_{i}+\epsilon) }  
$$
对上式上下除以$|\omega|$:

$$
a_{k} = \frac{ \frac{1}{|\omega|} \sum_{i\in \omega_{k}}I_{i}p_{i}-   \frac{1}{|\omega|} \sum_{i\in \omega_{k}}I_{i} \overline{p}_{k}} {\frac{1}{|\omega|}\sum_{i\in \omega_{k}}I_{i}^2  - \frac{1}{|\omega|}\sum_{i\in \omega_{k}} I_{i}\mu_{k} + \epsilon}
$$

上式分子中$   \frac{1}{|\omega|} \sum_{i\in \omega_{k}}I_{i} =  \mu_{k}  ​$，分母中，$\frac{1}{|\omega|}\sum_{i\in \omega_{k}}I_{i}^2  - \frac{1}{|\omega|}\sum_{i\in \omega_{k}} I_{i}\mu_{k} =E(I^2) - E(I)^2 = \sigma_{k}^2 ​$ ，也就是窗口 $\omega​$中像素的方差。因此，参数$a​$最终的表达是如下:

$$
a_{k} =  \frac{\frac{1}{|\omega|}  \sum_{i\in \omega_{k}}I_{i}p_{i} - \mu_{k} \overline{p}_{k} }
 { \sigma_{k}^2 + \epsilon}
$$

 一般情况下，我们所使用的引导图像就是图像本身，也就是 $I \equiv p​$，那么$a_{k}= \sigma_{k}^2/(\sigma_{k}^2 + \epsilon)​$，$b_{k} = (1-a_{k})\mu_{k}​$，考虑窗口内“高方差”和“低方差”的两种情况：
 “高方差”：$ \sigma_{k}^2 \gg  \epsilon​$，那么$a_{k}\approx 1​$，$b_{k}\approx 0​$
 “低方差”：$ \sigma_{k}^2 \ll  \epsilon​$，那么$a_{k}\approx 0​$，$b_{k}\approx \mu_{k}​$
  也就是，在高方差的地方，保持梯度，在低方差的时候尽量平滑（取值为平均值），这和我们的前面的期望是一样的。

 然而，如果滤波窗口为$w​$，那么任意一个像素都存在$w\times w$个窗口包含它，也就是说存在$w\times w​$个上述$a_{k}​$ 和 $b_{k}​$，为了处理该问题，最简单的方式就是将这些值做平均：
$$q_{i} = \overline{a}_{i}I_{i}+\overline{b}_{i} ​$$

其中$\overline{a}_{i}$为所有包含像素$i$的窗口所得$a_{k}$的平均值，也就是：
$$
\overline{a}_{i} = \frac{1}{|\omega|} \sum_{k \in \omega_{i}}a_{k} 
$$
同理可得对应的$\overline{b}_{i}$。

这一步的非常有必要，如果每个像素的输出值仅仅由使其为窗口中心窗口所对应的$a_{k}$和$b_{k}$决定，图像很容易存在artifacts，这样做的目的其实是对所有映射进行平滑，消除图像的artifacts。那么我们在matlab中如何实现引导滤波器呢？首先，对每一个像素求导其对应的$a_{k}$和$b_{k}$系数：

### 加权最小二乘法滤波器
对于给定的一幅图像$g$，如果一方面希望输出图像$u$与其很接近，另一方面又希望在除了边缘的地方越平滑越好$g$，全局来看，这是两个矛盾的东西，加权最小二乘法的作者认为，最优化这对矛盾的方式就是最小化下面的Cost function：
$$
 \sum_{p}((u_{p}-g_{p})^2 + \lambda(a_{x,p}(\frac{\partial u}{\partial x})_{p}^2+a_{y,p}(\frac{\partial u}{\partial y})_{p}^2))   
$$

其中$p$ 表示像素的物理位置，$(u_{p}-g_{p})^2 $这一项就是约束让输入和输出尽量接近，后面的一项则是为了让输出$u$在两个方向的导数越小越好，也就是越平滑越好。当然，平滑的贡献由$a_{x,p}$和$a_{y,p}$两个权重因子控制。$\lambda$控制还原度和平滑度之间的权重。因为在图像中，一维梯度表示为$ \frac{\partial u}{\partial x}$或者$ \frac{\partial u}{\partial y}$，也就是在$u$上施加的一个算子$\frac{\partial }{\partial x}$或者$\frac{\partial }{\partial y}$， 那么我们可以认为$ \frac{\partial u}{\partial x}$ 等效应$f(u)$，$f$就是这算子$\frac{\partial }{\partial x}$ 或者$\frac{\partial }{\partial x}$。因为在图像中这两个算子在任何位置都是不变的，我们姑且认为它们是常量，这样$\frac{\partial u}{\partial x}$可以写成$\frac{\partial }{\partial x}u$，这样，我们就可以对$u$进行求导,根据链式法则：

$$
 \sum_{p}(2(u_{p}-g_{p}) +2\lambda a_{x,p}\frac{\partial  }{\partial x} u_{p} \frac{\partial }{\partial x} + 2\lambda a_{y,p}\frac{\partial  }{\partial y} u_{p} \frac{\partial }{\partial y}) 
$$


上面的表示中，两次一阶梯度算子等于一次二阶梯度算子，同样的，将其看做常量，因此进一步化简：

$$
 \sum_{p}(2(u_{p}-g_{p}) +2\lambda a_{x,p}\frac{\partial ^2 }{\partial ^2x}u_{p} + 2\lambda a_{y,p}\frac{\partial ^2 }{\partial ^2y}u_{p}) 
$$
当上式等于0时，损失函数值最小，也就是：

$$
\sum_{p}((u_{p}-g_{p}) +\lambda a_{x,p}\frac{\partial ^2 }{\partial ^2x}u_{p} + \lambda a_{y,p}\frac{\partial ^2 }{\partial ^2y}u_{p} ) = 0 
$$

亦即：

$$
u(1+\lambda (a_{x}\frac{\partial ^2 }{\partial ^2x} + a_{y}\frac{\partial ^2 }{\partial ^2y})) =  g
$$

 文中，上式中$a_{x}$和$a_{y}$分别如下：

$$
a_{x,p} = (|\frac{\partial l}{\partial x}(p)|^\alpha + \epsilon)^{-1}
$$
$$
a_{y,p} = (|\frac{\partial l}{\partial y}(p)|^\alpha + \epsilon)^{-1}
$$

其中，$l$为图像经过log运算后结果，$\alpha$取值在1.2到2.0之间，用于控制其对梯度的敏感度，$\epsilon$是用于防止出现计算结果出现0的一个极小值。

